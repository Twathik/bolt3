# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateConsultation {
  _avg: ConsultationAvgAggregate
  _count: ConsultationCountAggregate
  _max: ConsultationMaxAggregate
  _min: ConsultationMinAggregate
  _sum: ConsultationSumAggregate
}

type AggregateConsultationList {
  _count: ConsultationListCountAggregate
  _max: ConsultationListMaxAggregate
  _min: ConsultationListMinAggregate
}

type AggregateMobileDevice {
  _count: MobileDeviceCountAggregate
  _max: MobileDeviceMaxAggregate
  _min: MobileDeviceMinAggregate
}

type AggregatePatient {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
}

type AggregateSetting {
  _avg: SettingAvgAggregate
  _count: SettingCountAggregate
  _max: SettingMaxAggregate
  _min: SettingMinAggregate
  _sum: SettingSumAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CloseAllTabsMessage {
  message: String!
}

type Consultation {
  ConsultationList(cursor: ConsultationListWhereUniqueInput, distinct: [ConsultationListScalarFieldEnum!], orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): [ConsultationList!]!
  _count: ConsultationCount
  createdAt: DateTimeISO!
  day: Int!
  id: String!
  month: Int!
  year: Int!
}

type ConsultationAvgAggregate {
  day: Float
  month: Float
  year: Float
}

input ConsultationAvgOrderByAggregateInput {
  day: SortOrder
  month: SortOrder
  year: SortOrder
}

type ConsultationCount {
  ConsultationList(where: ConsultationListWhereInput): Int!
}

type ConsultationCountAggregate {
  _all: Int!
  createdAt: Int!
  day: Int!
  id: Int!
  month: Int!
  year: Int!
}

input ConsultationCountOrderByAggregateInput {
  createdAt: SortOrder
  day: SortOrder
  id: SortOrder
  month: SortOrder
  year: SortOrder
}

input ConsultationCreateInput {
  ConsultationList: ConsultationListCreateNestedManyWithoutConsultationInput
  createdAt: DateTimeISO
  day: Int!
  id: String
  month: Int!
  year: Int!
}

input ConsultationCreateManyInput {
  createdAt: DateTimeISO
  day: Int!
  id: String
  month: Int!
  year: Int!
}

input ConsultationCreateNestedOneWithoutConsultationListInput {
  connect: ConsultationWhereUniqueInput
  connectOrCreate: ConsultationCreateOrConnectWithoutConsultationListInput
  create: ConsultationCreateWithoutConsultationListInput
}

input ConsultationCreateOrConnectWithoutConsultationListInput {
  create: ConsultationCreateWithoutConsultationListInput!
  where: ConsultationWhereUniqueInput!
}

input ConsultationCreateWithoutConsultationListInput {
  createdAt: DateTimeISO
  day: Int!
  id: String
  month: Int!
  year: Int!
}

type ConsultationGroupBy {
  _avg: ConsultationAvgAggregate
  _count: ConsultationCountAggregate
  _max: ConsultationMaxAggregate
  _min: ConsultationMinAggregate
  _sum: ConsultationSumAggregate
  createdAt: DateTimeISO!
  day: Int!
  id: String!
  month: Int!
  year: Int!
}

type ConsultationList {
  active: Boolean!
  consultation: Consultation!
  consultationId: String!
  createdAt: DateTimeISO!
  id: String!
  patient: Patient!
  patientId: String!
  updatedAt: DateTimeISO!
}

type ConsultationListCountAggregate {
  _all: Int!
  active: Int!
  consultationId: Int!
  createdAt: Int!
  id: Int!
  patientId: Int!
  updatedAt: Int!
}

input ConsultationListCountOrderByAggregateInput {
  active: SortOrder
  consultationId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  patientId: SortOrder
  updatedAt: SortOrder
}

input ConsultationListCreateInput {
  active: Boolean
  consultation: ConsultationCreateNestedOneWithoutConsultationListInput!
  createdAt: DateTimeISO
  id: String
  patient: PatientCreateNestedOneWithoutConsultationListInput!
  updatedAt: DateTimeISO
}

input ConsultationListCreateManyConsultationInput {
  active: Boolean
  createdAt: DateTimeISO
  id: String
  patientId: String!
  updatedAt: DateTimeISO
}

input ConsultationListCreateManyConsultationInputEnvelope {
  data: [ConsultationListCreateManyConsultationInput!]!
  skipDuplicates: Boolean
}

input ConsultationListCreateManyInput {
  active: Boolean
  consultationId: String!
  createdAt: DateTimeISO
  id: String
  patientId: String!
  updatedAt: DateTimeISO
}

input ConsultationListCreateManyPatientInput {
  active: Boolean
  consultationId: String!
  createdAt: DateTimeISO
  id: String
  updatedAt: DateTimeISO
}

input ConsultationListCreateManyPatientInputEnvelope {
  data: [ConsultationListCreateManyPatientInput!]!
  skipDuplicates: Boolean
}

input ConsultationListCreateNestedManyWithoutConsultationInput {
  connect: [ConsultationListWhereUniqueInput!]
  connectOrCreate: [ConsultationListCreateOrConnectWithoutConsultationInput!]
  create: [ConsultationListCreateWithoutConsultationInput!]
  createMany: ConsultationListCreateManyConsultationInputEnvelope
}

input ConsultationListCreateNestedManyWithoutPatientInput {
  connect: [ConsultationListWhereUniqueInput!]
  connectOrCreate: [ConsultationListCreateOrConnectWithoutPatientInput!]
  create: [ConsultationListCreateWithoutPatientInput!]
  createMany: ConsultationListCreateManyPatientInputEnvelope
}

input ConsultationListCreateOrConnectWithoutConsultationInput {
  create: ConsultationListCreateWithoutConsultationInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListCreateOrConnectWithoutPatientInput {
  create: ConsultationListCreateWithoutPatientInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListCreateWithoutConsultationInput {
  active: Boolean
  createdAt: DateTimeISO
  id: String
  patient: PatientCreateNestedOneWithoutConsultationListInput!
  updatedAt: DateTimeISO
}

input ConsultationListCreateWithoutPatientInput {
  active: Boolean
  consultation: ConsultationCreateNestedOneWithoutConsultationListInput!
  createdAt: DateTimeISO
  id: String
  updatedAt: DateTimeISO
}

type ConsultationListGroupBy {
  _count: ConsultationListCountAggregate
  _max: ConsultationListMaxAggregate
  _min: ConsultationListMinAggregate
  active: Boolean!
  consultationId: String!
  createdAt: DateTimeISO!
  id: String!
  patientId: String!
  updatedAt: DateTimeISO!
}

input ConsultationListListRelationFilter {
  every: ConsultationListWhereInput
  none: ConsultationListWhereInput
  some: ConsultationListWhereInput
}

type ConsultationListMaxAggregate {
  active: Boolean
  consultationId: String
  createdAt: DateTimeISO
  id: String
  patientId: String
  updatedAt: DateTimeISO
}

input ConsultationListMaxOrderByAggregateInput {
  active: SortOrder
  consultationId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  patientId: SortOrder
  updatedAt: SortOrder
}

type ConsultationListMinAggregate {
  active: Boolean
  consultationId: String
  createdAt: DateTimeISO
  id: String
  patientId: String
  updatedAt: DateTimeISO
}

input ConsultationListMinOrderByAggregateInput {
  active: SortOrder
  consultationId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  patientId: SortOrder
  updatedAt: SortOrder
}

input ConsultationListOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConsultationListOrderByWithAggregationInput {
  _count: ConsultationListCountOrderByAggregateInput
  _max: ConsultationListMaxOrderByAggregateInput
  _min: ConsultationListMinOrderByAggregateInput
  active: SortOrder
  consultationId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  patientId: SortOrder
  updatedAt: SortOrder
}

input ConsultationListOrderByWithRelationInput {
  active: SortOrder
  consultation: ConsultationOrderByWithRelationInput
  consultationId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  patient: PatientOrderByWithRelationInput
  patientId: SortOrder
  updatedAt: SortOrder
}

input ConsultationListPatientIdConsultationIdActiveCompoundUniqueInput {
  active: Boolean!
  consultationId: String!
  patientId: String!
}

enum ConsultationListScalarFieldEnum {
  active
  consultationId
  createdAt
  id
  patientId
  updatedAt
}

input ConsultationListScalarWhereInput {
  AND: [ConsultationListScalarWhereInput!]
  NOT: [ConsultationListScalarWhereInput!]
  OR: [ConsultationListScalarWhereInput!]
  active: BoolFilter
  consultationId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  patientId: StringFilter
  updatedAt: DateTimeFilter
}

input ConsultationListScalarWhereWithAggregatesInput {
  AND: [ConsultationListScalarWhereWithAggregatesInput!]
  NOT: [ConsultationListScalarWhereWithAggregatesInput!]
  OR: [ConsultationListScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  consultationId: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  patientId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input ConsultationListUpdateInput {
  active: BoolFieldUpdateOperationsInput
  consultation: ConsultationUpdateOneRequiredWithoutConsultationListNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patient: PatientUpdateOneRequiredWithoutConsultationListNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ConsultationListUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ConsultationListUpdateManyWithWhereWithoutConsultationInput {
  data: ConsultationListUpdateManyMutationInput!
  where: ConsultationListScalarWhereInput!
}

input ConsultationListUpdateManyWithWhereWithoutPatientInput {
  data: ConsultationListUpdateManyMutationInput!
  where: ConsultationListScalarWhereInput!
}

input ConsultationListUpdateManyWithoutConsultationNestedInput {
  connect: [ConsultationListWhereUniqueInput!]
  connectOrCreate: [ConsultationListCreateOrConnectWithoutConsultationInput!]
  create: [ConsultationListCreateWithoutConsultationInput!]
  createMany: ConsultationListCreateManyConsultationInputEnvelope
  delete: [ConsultationListWhereUniqueInput!]
  deleteMany: [ConsultationListScalarWhereInput!]
  disconnect: [ConsultationListWhereUniqueInput!]
  set: [ConsultationListWhereUniqueInput!]
  update: [ConsultationListUpdateWithWhereUniqueWithoutConsultationInput!]
  updateMany: [ConsultationListUpdateManyWithWhereWithoutConsultationInput!]
  upsert: [ConsultationListUpsertWithWhereUniqueWithoutConsultationInput!]
}

input ConsultationListUpdateManyWithoutPatientNestedInput {
  connect: [ConsultationListWhereUniqueInput!]
  connectOrCreate: [ConsultationListCreateOrConnectWithoutPatientInput!]
  create: [ConsultationListCreateWithoutPatientInput!]
  createMany: ConsultationListCreateManyPatientInputEnvelope
  delete: [ConsultationListWhereUniqueInput!]
  deleteMany: [ConsultationListScalarWhereInput!]
  disconnect: [ConsultationListWhereUniqueInput!]
  set: [ConsultationListWhereUniqueInput!]
  update: [ConsultationListUpdateWithWhereUniqueWithoutPatientInput!]
  updateMany: [ConsultationListUpdateManyWithWhereWithoutPatientInput!]
  upsert: [ConsultationListUpsertWithWhereUniqueWithoutPatientInput!]
}

input ConsultationListUpdateWithWhereUniqueWithoutConsultationInput {
  data: ConsultationListUpdateWithoutConsultationInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListUpdateWithWhereUniqueWithoutPatientInput {
  data: ConsultationListUpdateWithoutPatientInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListUpdateWithoutConsultationInput {
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patient: PatientUpdateOneRequiredWithoutConsultationListNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ConsultationListUpdateWithoutPatientInput {
  active: BoolFieldUpdateOperationsInput
  consultation: ConsultationUpdateOneRequiredWithoutConsultationListNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ConsultationListUpsertWithWhereUniqueWithoutConsultationInput {
  create: ConsultationListCreateWithoutConsultationInput!
  update: ConsultationListUpdateWithoutConsultationInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListUpsertWithWhereUniqueWithoutPatientInput {
  create: ConsultationListCreateWithoutPatientInput!
  update: ConsultationListUpdateWithoutPatientInput!
  where: ConsultationListWhereUniqueInput!
}

input ConsultationListWhereInput {
  AND: [ConsultationListWhereInput!]
  NOT: [ConsultationListWhereInput!]
  OR: [ConsultationListWhereInput!]
  active: BoolFilter
  consultation: ConsultationRelationFilter
  consultationId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  patient: PatientRelationFilter
  patientId: StringFilter
  updatedAt: DateTimeFilter
}

input ConsultationListWhereUniqueInput {
  AND: [ConsultationListWhereInput!]
  NOT: [ConsultationListWhereInput!]
  OR: [ConsultationListWhereInput!]
  active: BoolFilter
  consultation: ConsultationRelationFilter
  consultationId: StringFilter
  createdAt: DateTimeFilter
  id: String
  patient: PatientRelationFilter
  patientId: StringFilter
  patientId_consultationId_active: ConsultationListPatientIdConsultationIdActiveCompoundUniqueInput
  updatedAt: DateTimeFilter
}

type ConsultationMaxAggregate {
  createdAt: DateTimeISO
  day: Int
  id: String
  month: Int
  year: Int
}

input ConsultationMaxOrderByAggregateInput {
  createdAt: SortOrder
  day: SortOrder
  id: SortOrder
  month: SortOrder
  year: SortOrder
}

type ConsultationMinAggregate {
  createdAt: DateTimeISO
  day: Int
  id: String
  month: Int
  year: Int
}

input ConsultationMinOrderByAggregateInput {
  createdAt: SortOrder
  day: SortOrder
  id: SortOrder
  month: SortOrder
  year: SortOrder
}

input ConsultationOrderByWithAggregationInput {
  _avg: ConsultationAvgOrderByAggregateInput
  _count: ConsultationCountOrderByAggregateInput
  _max: ConsultationMaxOrderByAggregateInput
  _min: ConsultationMinOrderByAggregateInput
  _sum: ConsultationSumOrderByAggregateInput
  createdAt: SortOrder
  day: SortOrder
  id: SortOrder
  month: SortOrder
  year: SortOrder
}

input ConsultationOrderByWithRelationInput {
  ConsultationList: ConsultationListOrderByRelationAggregateInput
  createdAt: SortOrder
  day: SortOrder
  id: SortOrder
  month: SortOrder
  year: SortOrder
}

input ConsultationRelationFilter {
  is: ConsultationWhereInput
  isNot: ConsultationWhereInput
}

enum ConsultationScalarFieldEnum {
  createdAt
  day
  id
  month
  year
}

input ConsultationScalarWhereWithAggregatesInput {
  AND: [ConsultationScalarWhereWithAggregatesInput!]
  NOT: [ConsultationScalarWhereWithAggregatesInput!]
  OR: [ConsultationScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  day: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  month: IntWithAggregatesFilter
  year: IntWithAggregatesFilter
}

type ConsultationSumAggregate {
  day: Int
  month: Int
  year: Int
}

input ConsultationSumOrderByAggregateInput {
  day: SortOrder
  month: SortOrder
  year: SortOrder
}

input ConsultationUpdateInput {
  ConsultationList: ConsultationListUpdateManyWithoutConsultationNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  day: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  month: IntFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input ConsultationUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  day: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  month: IntFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input ConsultationUpdateOneRequiredWithoutConsultationListNestedInput {
  connect: ConsultationWhereUniqueInput
  connectOrCreate: ConsultationCreateOrConnectWithoutConsultationListInput
  create: ConsultationCreateWithoutConsultationListInput
  update: ConsultationUpdateToOneWithWhereWithoutConsultationListInput
  upsert: ConsultationUpsertWithoutConsultationListInput
}

input ConsultationUpdateToOneWithWhereWithoutConsultationListInput {
  data: ConsultationUpdateWithoutConsultationListInput!
  where: ConsultationWhereInput
}

input ConsultationUpdateWithoutConsultationListInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  day: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  month: IntFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input ConsultationUpsertWithoutConsultationListInput {
  create: ConsultationCreateWithoutConsultationListInput!
  update: ConsultationUpdateWithoutConsultationListInput!
  where: ConsultationWhereInput
}

input ConsultationWhereInput {
  AND: [ConsultationWhereInput!]
  ConsultationList: ConsultationListListRelationFilter
  NOT: [ConsultationWhereInput!]
  OR: [ConsultationWhereInput!]
  createdAt: DateTimeFilter
  day: IntFilter
  id: StringFilter
  month: IntFilter
  year: IntFilter
}

input ConsultationWhereUniqueInput {
  AND: [ConsultationWhereInput!]
  ConsultationList: ConsultationListListRelationFilter
  NOT: [ConsultationWhereInput!]
  OR: [ConsultationWhereInput!]
  createdAt: DateTimeFilter
  day: IntFilter
  id: String
  month: IntFilter
  year: IntFilter
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input EnumMobileDeviceTypeFieldUpdateOperationsInput {
  set: MobileDeviceType
}

input EnumMobileDeviceTypeFilter {
  equals: MobileDeviceType
  in: [MobileDeviceType!]
  not: NestedEnumMobileDeviceTypeFilter
  notIn: [MobileDeviceType!]
}

input EnumMobileDeviceTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMobileDeviceTypeFilter
  _min: NestedEnumMobileDeviceTypeFilter
  equals: MobileDeviceType
  in: [MobileDeviceType!]
  not: NestedEnumMobileDeviceTypeWithAggregatesFilter
  notIn: [MobileDeviceType!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input EnumSexeFieldUpdateOperationsInput {
  set: Sexe
}

input EnumSexeFilter {
  equals: Sexe
  in: [Sexe!]
  not: NestedEnumSexeFilter
  notIn: [Sexe!]
}

input EnumSexeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumSexeFilter
  _min: NestedEnumSexeFilter
  equals: Sexe
  in: [Sexe!]
  not: NestedEnumSexeWithAggregatesFilter
  notIn: [Sexe!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type MobileDevice {
  accessToken: String!
  connected: Boolean!
  expireAt: DateTimeISO!
  id: String!
  mobileDeviceType: MobileDeviceType!
  uuid: String!
}

type MobileDeviceCountAggregate {
  _all: Int!
  accessToken: Int!
  connected: Int!
  expireAt: Int!
  id: Int!
  mobileDeviceType: Int!
  uuid: Int!
}

input MobileDeviceCountOrderByAggregateInput {
  accessToken: SortOrder
  connected: SortOrder
  expireAt: SortOrder
  id: SortOrder
  mobileDeviceType: SortOrder
  uuid: SortOrder
}

input MobileDeviceCreateInput {
  accessToken: String!
  connected: Boolean
  expireAt: DateTimeISO!
  id: String
  mobileDeviceType: MobileDeviceType
  uuid: String!
}

input MobileDeviceCreateManyInput {
  accessToken: String!
  connected: Boolean
  expireAt: DateTimeISO!
  id: String
  mobileDeviceType: MobileDeviceType
  uuid: String!
}

type MobileDeviceGroupBy {
  _count: MobileDeviceCountAggregate
  _max: MobileDeviceMaxAggregate
  _min: MobileDeviceMinAggregate
  accessToken: String!
  connected: Boolean!
  expireAt: DateTimeISO!
  id: String!
  mobileDeviceType: MobileDeviceType!
  uuid: String!
}

type MobileDeviceMaxAggregate {
  accessToken: String
  connected: Boolean
  expireAt: DateTimeISO
  id: String
  mobileDeviceType: MobileDeviceType
  uuid: String
}

input MobileDeviceMaxOrderByAggregateInput {
  accessToken: SortOrder
  connected: SortOrder
  expireAt: SortOrder
  id: SortOrder
  mobileDeviceType: SortOrder
  uuid: SortOrder
}

type MobileDeviceMinAggregate {
  accessToken: String
  connected: Boolean
  expireAt: DateTimeISO
  id: String
  mobileDeviceType: MobileDeviceType
  uuid: String
}

input MobileDeviceMinOrderByAggregateInput {
  accessToken: SortOrder
  connected: SortOrder
  expireAt: SortOrder
  id: SortOrder
  mobileDeviceType: SortOrder
  uuid: SortOrder
}

input MobileDeviceOrderByWithAggregationInput {
  _count: MobileDeviceCountOrderByAggregateInput
  _max: MobileDeviceMaxOrderByAggregateInput
  _min: MobileDeviceMinOrderByAggregateInput
  accessToken: SortOrder
  connected: SortOrder
  expireAt: SortOrder
  id: SortOrder
  mobileDeviceType: SortOrder
  uuid: SortOrder
}

input MobileDeviceOrderByWithRelationInput {
  accessToken: SortOrder
  connected: SortOrder
  expireAt: SortOrder
  id: SortOrder
  mobileDeviceType: SortOrder
  uuid: SortOrder
}

enum MobileDeviceScalarFieldEnum {
  accessToken
  connected
  expireAt
  id
  mobileDeviceType
  uuid
}

input MobileDeviceScalarWhereWithAggregatesInput {
  AND: [MobileDeviceScalarWhereWithAggregatesInput!]
  NOT: [MobileDeviceScalarWhereWithAggregatesInput!]
  OR: [MobileDeviceScalarWhereWithAggregatesInput!]
  accessToken: StringWithAggregatesFilter
  connected: BoolWithAggregatesFilter
  expireAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  mobileDeviceType: EnumMobileDeviceTypeWithAggregatesFilter
  uuid: StringWithAggregatesFilter
}

enum MobileDeviceType {
  DOCTOR
  SECRETARY
}

input MobileDeviceUpdateInput {
  accessToken: StringFieldUpdateOperationsInput
  connected: BoolFieldUpdateOperationsInput
  expireAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  mobileDeviceType: EnumMobileDeviceTypeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input MobileDeviceUpdateManyMutationInput {
  accessToken: StringFieldUpdateOperationsInput
  connected: BoolFieldUpdateOperationsInput
  expireAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  mobileDeviceType: EnumMobileDeviceTypeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input MobileDeviceUuidAccessTokenCompoundUniqueInput {
  accessToken: String!
  uuid: String!
}

input MobileDeviceWhereInput {
  AND: [MobileDeviceWhereInput!]
  NOT: [MobileDeviceWhereInput!]
  OR: [MobileDeviceWhereInput!]
  accessToken: StringFilter
  connected: BoolFilter
  expireAt: DateTimeFilter
  id: StringFilter
  mobileDeviceType: EnumMobileDeviceTypeFilter
  uuid: StringFilter
}

input MobileDeviceWhereUniqueInput {
  AND: [MobileDeviceWhereInput!]
  NOT: [MobileDeviceWhereInput!]
  OR: [MobileDeviceWhereInput!]
  accessToken: String
  connected: BoolFilter
  expireAt: DateTimeFilter
  id: String
  mobileDeviceType: EnumMobileDeviceTypeFilter
  uuid: StringFilter
  uuid_accessToken: MobileDeviceUuidAccessTokenCompoundUniqueInput
}

type Mutation {
  AddOnePatientToIndex(data: PatientCreateInput!): Patient!
  changeExpirationMobileDeviceResolver(Months: Int!, id: String!): Boolean
  closeAllTabs(message: String!): Boolean!
  createManyConsultation(data: [ConsultationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyConsultationList(data: [ConsultationListCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMobileDevice(data: [MobileDeviceCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPatient(data: [PatientCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySetting(data: [SettingCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneConsultation(data: ConsultationCreateInput!): Consultation!
  createOneConsultationList(data: ConsultationListCreateInput!): ConsultationList!
  createOneMobileDevice(data: MobileDeviceCreateInput!): MobileDevice!
  createOnePatient(data: PatientCreateInput!): Patient!
  createOneSetting(data: SettingCreateInput): Setting!
  createOneUser(data: UserCreateInput!): User!
  deleteManyConsultation(where: ConsultationWhereInput): AffectedRowsOutput!
  deleteManyConsultationList(where: ConsultationListWhereInput): AffectedRowsOutput!
  deleteManyMobileDevice(where: MobileDeviceWhereInput): AffectedRowsOutput!
  deleteManyPatient(where: PatientWhereInput): AffectedRowsOutput!
  deleteManySetting(where: SettingWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneConsultation(where: ConsultationWhereUniqueInput!): Consultation
  deleteOneConsultationList(where: ConsultationListWhereUniqueInput!): ConsultationList
  deleteOneMobileDevice(where: MobileDeviceWhereUniqueInput!): MobileDevice
  deleteOnePatient(where: PatientWhereUniqueInput!): Patient
  deleteOneSetting(where: SettingWhereUniqueInput!): Setting
  deleteOneUser(where: UserWhereUniqueInput!): User
  emptyTrashMutation(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): AffectedRowsOutput!
  indexPatients: Boolean
  movePatientFolderToTrash(id: String!, onTrash: Boolean!): Patient
  registerOneMobileDevice(accessToken: String!, uuid: String!): MobileDevice
  registerPatient(patient_id: String!): String!
  switchMobileDevice(id: String!, mobileDeviceType: MobileDeviceType!): Boolean
  triggerGetAllMobileDevicesSubscription: Boolean!
  triggerGetUpdatedPatientSubscription(id: String!): Boolean!
  updateManyConsultation(data: ConsultationUpdateManyMutationInput!, where: ConsultationWhereInput): AffectedRowsOutput!
  updateManyConsultationList(data: ConsultationListUpdateManyMutationInput!, where: ConsultationListWhereInput): AffectedRowsOutput!
  updateManyMobileDevice(data: MobileDeviceUpdateManyMutationInput!, where: MobileDeviceWhereInput): AffectedRowsOutput!
  updateManyPatient(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): AffectedRowsOutput!
  updateManySetting(data: SettingUpdateManyMutationInput!, where: SettingWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneConsultation(data: ConsultationUpdateInput!, where: ConsultationWhereUniqueInput!): Consultation
  updateOneConsultationList(data: ConsultationListUpdateInput!, where: ConsultationListWhereUniqueInput!): ConsultationList
  updateOneMobileDevice(data: MobileDeviceUpdateInput!, where: MobileDeviceWhereUniqueInput!): MobileDevice
  updateOnePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateOneSetting(data: SettingUpdateInput!, where: SettingWhereUniqueInput!): Setting
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneConsultation(create: ConsultationCreateInput!, update: ConsultationUpdateInput!, where: ConsultationWhereUniqueInput!): Consultation!
  upsertOneConsultationList(create: ConsultationListCreateInput!, update: ConsultationListUpdateInput!, where: ConsultationListWhereUniqueInput!): ConsultationList!
  upsertOneMobileDevice(create: MobileDeviceCreateInput!, update: MobileDeviceUpdateInput!, where: MobileDeviceWhereUniqueInput!): MobileDevice!
  upsertOnePatient(create: PatientCreateInput!, update: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient!
  upsertOneSetting(create: SettingCreateInput!, update: SettingUpdateInput!, where: SettingWhereUniqueInput!): Setting!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedEnumMobileDeviceTypeFilter {
  equals: MobileDeviceType
  in: [MobileDeviceType!]
  not: NestedEnumMobileDeviceTypeFilter
  notIn: [MobileDeviceType!]
}

input NestedEnumMobileDeviceTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumMobileDeviceTypeFilter
  _min: NestedEnumMobileDeviceTypeFilter
  equals: MobileDeviceType
  in: [MobileDeviceType!]
  not: NestedEnumMobileDeviceTypeWithAggregatesFilter
  notIn: [MobileDeviceType!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedEnumSexeFilter {
  equals: Sexe
  in: [Sexe!]
  not: NestedEnumSexeFilter
  notIn: [Sexe!]
}

input NestedEnumSexeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumSexeFilter
  _min: NestedEnumSexeFilter
  equals: Sexe
  in: [Sexe!]
  not: NestedEnumSexeWithAggregatesFilter
  notIn: [Sexe!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Patient {
  ConsultationList(cursor: ConsultationListWhereUniqueInput, distinct: [ConsultationListScalarFieldEnum!], orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): [ConsultationList!]!
  _count: PatientCount
  address: String
  createdAt: DateTimeISO!
  ddn: DateTimeISO!
  deleted: Boolean!
  firstName: String!
  id: String!
  informationsConfirmed: Boolean!
  lastName: String!
  nTel: String
  onTrash: Boolean!
  patientFullName: String!
  sexe: Sexe!
  updated: DateTimeISO!
}

type PatientCount {
  ConsultationList(where: ConsultationListWhereInput): Int!
}

type PatientCountAggregate {
  _all: Int!
  address: Int!
  createdAt: Int!
  ddn: Int!
  deleted: Int!
  firstName: Int!
  id: Int!
  informationsConfirmed: Int!
  lastName: Int!
  nTel: Int!
  onTrash: Int!
  sexe: Int!
  updated: Int!
}

input PatientCountOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  ddn: SortOrder
  deleted: SortOrder
  firstName: SortOrder
  id: SortOrder
  informationsConfirmed: SortOrder
  lastName: SortOrder
  nTel: SortOrder
  onTrash: SortOrder
  sexe: SortOrder
  updated: SortOrder
}

input PatientCreateInput {
  ConsultationList: ConsultationListCreateNestedManyWithoutPatientInput
  address: String
  createdAt: DateTimeISO
  ddn: DateTimeISO!
  deleted: Boolean
  firstName: String!
  id: String
  informationsConfirmed: Boolean
  lastName: String!
  nTel: String
  onTrash: Boolean
  sexe: Sexe!
  updated: DateTimeISO
}

input PatientCreateManyInput {
  address: String
  createdAt: DateTimeISO
  ddn: DateTimeISO!
  deleted: Boolean
  firstName: String!
  id: String
  informationsConfirmed: Boolean
  lastName: String!
  nTel: String
  onTrash: Boolean
  sexe: Sexe!
  updated: DateTimeISO
}

input PatientCreateNestedOneWithoutConsultationListInput {
  connect: PatientWhereUniqueInput
  connectOrCreate: PatientCreateOrConnectWithoutConsultationListInput
  create: PatientCreateWithoutConsultationListInput
}

input PatientCreateOrConnectWithoutConsultationListInput {
  create: PatientCreateWithoutConsultationListInput!
  where: PatientWhereUniqueInput!
}

input PatientCreateWithoutConsultationListInput {
  address: String
  createdAt: DateTimeISO
  ddn: DateTimeISO!
  deleted: Boolean
  firstName: String!
  id: String
  informationsConfirmed: Boolean
  lastName: String!
  nTel: String
  onTrash: Boolean
  sexe: Sexe!
  updated: DateTimeISO
}

type PatientGroupBy {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
  address: String
  createdAt: DateTimeISO!
  ddn: DateTimeISO!
  deleted: Boolean!
  firstName: String!
  id: String!
  informationsConfirmed: Boolean!
  lastName: String!
  nTel: String
  onTrash: Boolean!
  sexe: Sexe!
  updated: DateTimeISO!
}

type PatientMaxAggregate {
  address: String
  createdAt: DateTimeISO
  ddn: DateTimeISO
  deleted: Boolean
  firstName: String
  id: String
  informationsConfirmed: Boolean
  lastName: String
  nTel: String
  onTrash: Boolean
  sexe: Sexe
  updated: DateTimeISO
}

input PatientMaxOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  ddn: SortOrder
  deleted: SortOrder
  firstName: SortOrder
  id: SortOrder
  informationsConfirmed: SortOrder
  lastName: SortOrder
  nTel: SortOrder
  onTrash: SortOrder
  sexe: SortOrder
  updated: SortOrder
}

type PatientMinAggregate {
  address: String
  createdAt: DateTimeISO
  ddn: DateTimeISO
  deleted: Boolean
  firstName: String
  id: String
  informationsConfirmed: Boolean
  lastName: String
  nTel: String
  onTrash: Boolean
  sexe: Sexe
  updated: DateTimeISO
}

input PatientMinOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  ddn: SortOrder
  deleted: SortOrder
  firstName: SortOrder
  id: SortOrder
  informationsConfirmed: SortOrder
  lastName: SortOrder
  nTel: SortOrder
  onTrash: SortOrder
  sexe: SortOrder
  updated: SortOrder
}

input PatientOrderByWithAggregationInput {
  _count: PatientCountOrderByAggregateInput
  _max: PatientMaxOrderByAggregateInput
  _min: PatientMinOrderByAggregateInput
  address: SortOrderInput
  createdAt: SortOrder
  ddn: SortOrder
  deleted: SortOrder
  firstName: SortOrder
  id: SortOrder
  informationsConfirmed: SortOrder
  lastName: SortOrder
  nTel: SortOrderInput
  onTrash: SortOrder
  sexe: SortOrder
  updated: SortOrder
}

input PatientOrderByWithRelationInput {
  ConsultationList: ConsultationListOrderByRelationAggregateInput
  address: SortOrderInput
  createdAt: SortOrder
  ddn: SortOrder
  deleted: SortOrder
  firstName: SortOrder
  id: SortOrder
  informationsConfirmed: SortOrder
  lastName: SortOrder
  nTel: SortOrderInput
  onTrash: SortOrder
  sexe: SortOrder
  updated: SortOrder
}

input PatientRelationFilter {
  is: PatientWhereInput
  isNot: PatientWhereInput
}

enum PatientScalarFieldEnum {
  address
  createdAt
  ddn
  deleted
  firstName
  id
  informationsConfirmed
  lastName
  nTel
  onTrash
  sexe
  updated
}

input PatientScalarWhereWithAggregatesInput {
  AND: [PatientScalarWhereWithAggregatesInput!]
  NOT: [PatientScalarWhereWithAggregatesInput!]
  OR: [PatientScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  ddn: DateTimeWithAggregatesFilter
  deleted: BoolWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  informationsConfirmed: BoolWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  nTel: StringNullableWithAggregatesFilter
  onTrash: BoolWithAggregatesFilter
  sexe: EnumSexeWithAggregatesFilter
  updated: DateTimeWithAggregatesFilter
}

input PatientUpdateInput {
  ConsultationList: ConsultationListUpdateManyWithoutPatientNestedInput
  address: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  ddn: DateTimeFieldUpdateOperationsInput
  deleted: BoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  informationsConfirmed: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  nTel: NullableStringFieldUpdateOperationsInput
  onTrash: BoolFieldUpdateOperationsInput
  sexe: EnumSexeFieldUpdateOperationsInput
  updated: DateTimeFieldUpdateOperationsInput
}

input PatientUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  ddn: DateTimeFieldUpdateOperationsInput
  deleted: BoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  informationsConfirmed: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  nTel: NullableStringFieldUpdateOperationsInput
  onTrash: BoolFieldUpdateOperationsInput
  sexe: EnumSexeFieldUpdateOperationsInput
  updated: DateTimeFieldUpdateOperationsInput
}

input PatientUpdateOneRequiredWithoutConsultationListNestedInput {
  connect: PatientWhereUniqueInput
  connectOrCreate: PatientCreateOrConnectWithoutConsultationListInput
  create: PatientCreateWithoutConsultationListInput
  update: PatientUpdateToOneWithWhereWithoutConsultationListInput
  upsert: PatientUpsertWithoutConsultationListInput
}

input PatientUpdateToOneWithWhereWithoutConsultationListInput {
  data: PatientUpdateWithoutConsultationListInput!
  where: PatientWhereInput
}

input PatientUpdateWithoutConsultationListInput {
  address: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  ddn: DateTimeFieldUpdateOperationsInput
  deleted: BoolFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  informationsConfirmed: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  nTel: NullableStringFieldUpdateOperationsInput
  onTrash: BoolFieldUpdateOperationsInput
  sexe: EnumSexeFieldUpdateOperationsInput
  updated: DateTimeFieldUpdateOperationsInput
}

input PatientUpsertWithoutConsultationListInput {
  create: PatientCreateWithoutConsultationListInput!
  update: PatientUpdateWithoutConsultationListInput!
  where: PatientWhereInput
}

input PatientWhereInput {
  AND: [PatientWhereInput!]
  ConsultationList: ConsultationListListRelationFilter
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  address: StringNullableFilter
  createdAt: DateTimeFilter
  ddn: DateTimeFilter
  deleted: BoolFilter
  firstName: StringFilter
  id: StringFilter
  informationsConfirmed: BoolFilter
  lastName: StringFilter
  nTel: StringNullableFilter
  onTrash: BoolFilter
  sexe: EnumSexeFilter
  updated: DateTimeFilter
}

input PatientWhereUniqueInput {
  AND: [PatientWhereInput!]
  ConsultationList: ConsultationListListRelationFilter
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  address: StringNullableFilter
  createdAt: DateTimeFilter
  ddn: DateTimeFilter
  deleted: BoolFilter
  firstName: StringFilter
  id: String
  informationsConfirmed: BoolFilter
  lastName: StringFilter
  nTel: StringNullableFilter
  onTrash: BoolFilter
  sexe: EnumSexeFilter
  updated: DateTimeFilter
}

type Query {
  aggregateConsultation(cursor: ConsultationWhereUniqueInput, orderBy: [ConsultationOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationWhereInput): AggregateConsultation!
  aggregateConsultationList(cursor: ConsultationListWhereUniqueInput, orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): AggregateConsultationList!
  aggregateMobileDevice(cursor: MobileDeviceWhereUniqueInput, orderBy: [MobileDeviceOrderByWithRelationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): AggregateMobileDevice!
  aggregatePatient(cursor: PatientWhereUniqueInput, orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): AggregatePatient!
  aggregateSetting(cursor: SettingWhereUniqueInput, orderBy: [SettingOrderByWithRelationInput!], skip: Int, take: Int, where: SettingWhereInput): AggregateSetting!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  authMobileApp(accessToken: String!, uuid: String!): MobileDevice!
  consultation(where: ConsultationWhereUniqueInput!): Consultation
  consultationList(where: ConsultationListWhereUniqueInput!): ConsultationList
  consultationLists(cursor: ConsultationListWhereUniqueInput, distinct: [ConsultationListScalarFieldEnum!], orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): [ConsultationList!]!
  consultations(cursor: ConsultationWhereUniqueInput, distinct: [ConsultationScalarFieldEnum!], orderBy: [ConsultationOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationWhereInput): [Consultation!]!
  findFirstConsultation(cursor: ConsultationWhereUniqueInput, distinct: [ConsultationScalarFieldEnum!], orderBy: [ConsultationOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationWhereInput): Consultation
  findFirstConsultationList(cursor: ConsultationListWhereUniqueInput, distinct: [ConsultationListScalarFieldEnum!], orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): ConsultationList
  findFirstConsultationListOrThrow(cursor: ConsultationListWhereUniqueInput, distinct: [ConsultationListScalarFieldEnum!], orderBy: [ConsultationListOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): ConsultationList
  findFirstConsultationOrThrow(cursor: ConsultationWhereUniqueInput, distinct: [ConsultationScalarFieldEnum!], orderBy: [ConsultationOrderByWithRelationInput!], skip: Int, take: Int, where: ConsultationWhereInput): Consultation
  findFirstMobileDevice(cursor: MobileDeviceWhereUniqueInput, distinct: [MobileDeviceScalarFieldEnum!], orderBy: [MobileDeviceOrderByWithRelationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): MobileDevice
  findFirstMobileDeviceOrThrow(cursor: MobileDeviceWhereUniqueInput, distinct: [MobileDeviceScalarFieldEnum!], orderBy: [MobileDeviceOrderByWithRelationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): MobileDevice
  findFirstPatient(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstPatientOrThrow(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstSetting(cursor: SettingWhereUniqueInput, distinct: [SettingScalarFieldEnum!], orderBy: [SettingOrderByWithRelationInput!], skip: Int, take: Int, where: SettingWhereInput): Setting
  findFirstSettingOrThrow(cursor: SettingWhereUniqueInput, distinct: [SettingScalarFieldEnum!], orderBy: [SettingOrderByWithRelationInput!], skip: Int, take: Int, where: SettingWhereInput): Setting
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getConsultation(where: ConsultationWhereUniqueInput!): Consultation
  getConsultationList(where: ConsultationListWhereUniqueInput!): ConsultationList
  getMobileDevice(where: MobileDeviceWhereUniqueInput!): MobileDevice
  getPatient(where: PatientWhereUniqueInput!): Patient
  getSetting(where: SettingWhereUniqueInput!): Setting
  getUser(where: UserWhereUniqueInput!): User
  groupByConsultation(by: [ConsultationScalarFieldEnum!]!, having: ConsultationScalarWhereWithAggregatesInput, orderBy: [ConsultationOrderByWithAggregationInput!], skip: Int, take: Int, where: ConsultationWhereInput): [ConsultationGroupBy!]!
  groupByConsultationList(by: [ConsultationListScalarFieldEnum!]!, having: ConsultationListScalarWhereWithAggregatesInput, orderBy: [ConsultationListOrderByWithAggregationInput!], skip: Int, take: Int, where: ConsultationListWhereInput): [ConsultationListGroupBy!]!
  groupByMobileDevice(by: [MobileDeviceScalarFieldEnum!]!, having: MobileDeviceScalarWhereWithAggregatesInput, orderBy: [MobileDeviceOrderByWithAggregationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): [MobileDeviceGroupBy!]!
  groupByPatient(by: [PatientScalarFieldEnum!]!, having: PatientScalarWhereWithAggregatesInput, orderBy: [PatientOrderByWithAggregationInput!], skip: Int, take: Int, where: PatientWhereInput): [PatientGroupBy!]!
  groupBySetting(by: [SettingScalarFieldEnum!]!, having: SettingScalarWhereWithAggregatesInput, orderBy: [SettingOrderByWithAggregationInput!], skip: Int, take: Int, where: SettingWhereInput): [SettingGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  mobileDevice(where: MobileDeviceWhereUniqueInput!): MobileDevice
  mobileDevices(cursor: MobileDeviceWhereUniqueInput, distinct: [MobileDeviceScalarFieldEnum!], orderBy: [MobileDeviceOrderByWithRelationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): [MobileDevice!]!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): [Patient!]!
  setting(where: SettingWhereUniqueInput!): Setting
  settings(cursor: SettingWhereUniqueInput, distinct: [SettingScalarFieldEnum!], orderBy: [SettingOrderByWithRelationInput!], skip: Int, take: Int, where: SettingWhereInput): [Setting!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

type Setting {
  allowedMobileDevices_doctors: Int!
  allowedMobileDevices_secretary: Int!
  id: String!
}

type SettingAvgAggregate {
  allowedMobileDevices_doctors: Float
  allowedMobileDevices_secretary: Float
}

input SettingAvgOrderByAggregateInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
}

type SettingCountAggregate {
  _all: Int!
  allowedMobileDevices_doctors: Int!
  allowedMobileDevices_secretary: Int!
  id: Int!
}

input SettingCountOrderByAggregateInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
  id: SortOrder
}

input SettingCreateInput {
  allowedMobileDevices_doctors: Int
  allowedMobileDevices_secretary: Int
  id: String
}

input SettingCreateManyInput {
  allowedMobileDevices_doctors: Int
  allowedMobileDevices_secretary: Int
  id: String
}

type SettingGroupBy {
  _avg: SettingAvgAggregate
  _count: SettingCountAggregate
  _max: SettingMaxAggregate
  _min: SettingMinAggregate
  _sum: SettingSumAggregate
  allowedMobileDevices_doctors: Int!
  allowedMobileDevices_secretary: Int!
  id: String!
}

type SettingMaxAggregate {
  allowedMobileDevices_doctors: Int
  allowedMobileDevices_secretary: Int
  id: String
}

input SettingMaxOrderByAggregateInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
  id: SortOrder
}

type SettingMinAggregate {
  allowedMobileDevices_doctors: Int
  allowedMobileDevices_secretary: Int
  id: String
}

input SettingMinOrderByAggregateInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
  id: SortOrder
}

input SettingOrderByWithAggregationInput {
  _avg: SettingAvgOrderByAggregateInput
  _count: SettingCountOrderByAggregateInput
  _max: SettingMaxOrderByAggregateInput
  _min: SettingMinOrderByAggregateInput
  _sum: SettingSumOrderByAggregateInput
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
  id: SortOrder
}

input SettingOrderByWithRelationInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
  id: SortOrder
}

enum SettingScalarFieldEnum {
  allowedMobileDevices_doctors
  allowedMobileDevices_secretary
  id
}

input SettingScalarWhereWithAggregatesInput {
  AND: [SettingScalarWhereWithAggregatesInput!]
  NOT: [SettingScalarWhereWithAggregatesInput!]
  OR: [SettingScalarWhereWithAggregatesInput!]
  allowedMobileDevices_doctors: IntWithAggregatesFilter
  allowedMobileDevices_secretary: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
}

type SettingSumAggregate {
  allowedMobileDevices_doctors: Int
  allowedMobileDevices_secretary: Int
}

input SettingSumOrderByAggregateInput {
  allowedMobileDevices_doctors: SortOrder
  allowedMobileDevices_secretary: SortOrder
}

input SettingUpdateInput {
  allowedMobileDevices_doctors: IntFieldUpdateOperationsInput
  allowedMobileDevices_secretary: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input SettingUpdateManyMutationInput {
  allowedMobileDevices_doctors: IntFieldUpdateOperationsInput
  allowedMobileDevices_secretary: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input SettingWhereInput {
  AND: [SettingWhereInput!]
  NOT: [SettingWhereInput!]
  OR: [SettingWhereInput!]
  allowedMobileDevices_doctors: IntFilter
  allowedMobileDevices_secretary: IntFilter
  id: StringFilter
}

input SettingWhereUniqueInput {
  AND: [SettingWhereInput!]
  NOT: [SettingWhereInput!]
  OR: [SettingWhereInput!]
  allowedMobileDevices_doctors: IntFilter
  allowedMobileDevices_secretary: IntFilter
  id: String
}

enum Sexe {
  F
  M
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  closeAllTabs: CloseAllTabsMessage!
  emptyTrashSubscription: [Patient!]!
  getMobileDevicesList(cursor: MobileDeviceWhereUniqueInput, distinct: [MobileDeviceScalarFieldEnum!], orderBy: [MobileDeviceOrderByWithRelationInput!], skip: Int, take: Int, where: MobileDeviceWhereInput): [MobileDevice!]!
  getUpdatedPatient(id: String!): Patient!
}

type User {
  avatarUrl: String
  createdAt: DateTimeISO!
  email: String!
  firstName: String
  fullName: String
  id: String!
  lastConnection: DateTimeISO!
  lastName: String
  phoneNumbers: [String!]!
  role: Role!
  typesenseApiKey: String
  userId: String!
}

type UserCountAggregate {
  _all: Int!
  avatarUrl: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  fullName: Int!
  id: Int!
  lastConnection: Int!
  lastName: Int!
  phoneNumbers: Int!
  role: Int!
  typesenseApiKey: Int!
  userId: Int!
}

input UserCountOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  fullName: SortOrder
  id: SortOrder
  lastConnection: SortOrder
  lastName: SortOrder
  phoneNumbers: SortOrder
  role: SortOrder
  typesenseApiKey: SortOrder
  userId: SortOrder
}

input UserCreateInput {
  avatarUrl: String
  createdAt: DateTimeISO
  email: String!
  firstName: String
  fullName: String
  id: String
  lastConnection: DateTimeISO
  lastName: String
  phoneNumbers: UserCreatephoneNumbersInput
  role: Role
  typesenseApiKey: String
  userId: String!
}

input UserCreateManyInput {
  avatarUrl: String
  createdAt: DateTimeISO
  email: String!
  firstName: String
  fullName: String
  id: String
  lastConnection: DateTimeISO
  lastName: String
  phoneNumbers: UserCreatephoneNumbersInput
  role: Role
  typesenseApiKey: String
  userId: String!
}

input UserCreatephoneNumbersInput {
  set: [String!]!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  avatarUrl: String
  createdAt: DateTimeISO!
  email: String!
  firstName: String
  fullName: String
  id: String!
  lastConnection: DateTimeISO!
  lastName: String
  phoneNumbers: [String!]
  role: Role!
  typesenseApiKey: String
  userId: String!
}

type UserMaxAggregate {
  avatarUrl: String
  createdAt: DateTimeISO
  email: String
  firstName: String
  fullName: String
  id: String
  lastConnection: DateTimeISO
  lastName: String
  role: Role
  typesenseApiKey: String
  userId: String
}

input UserMaxOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  fullName: SortOrder
  id: SortOrder
  lastConnection: SortOrder
  lastName: SortOrder
  role: SortOrder
  typesenseApiKey: SortOrder
  userId: SortOrder
}

type UserMinAggregate {
  avatarUrl: String
  createdAt: DateTimeISO
  email: String
  firstName: String
  fullName: String
  id: String
  lastConnection: DateTimeISO
  lastName: String
  role: Role
  typesenseApiKey: String
  userId: String
}

input UserMinOrderByAggregateInput {
  avatarUrl: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  fullName: SortOrder
  id: SortOrder
  lastConnection: SortOrder
  lastName: SortOrder
  role: SortOrder
  typesenseApiKey: SortOrder
  userId: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  avatarUrl: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrderInput
  fullName: SortOrderInput
  id: SortOrder
  lastConnection: SortOrder
  lastName: SortOrderInput
  phoneNumbers: SortOrder
  role: SortOrder
  typesenseApiKey: SortOrderInput
  userId: SortOrder
}

input UserOrderByWithRelationInput {
  avatarUrl: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrderInput
  fullName: SortOrderInput
  id: SortOrder
  lastConnection: SortOrder
  lastName: SortOrderInput
  phoneNumbers: SortOrder
  role: SortOrder
  typesenseApiKey: SortOrderInput
  userId: SortOrder
}

enum UserScalarFieldEnum {
  avatarUrl
  createdAt
  email
  firstName
  fullName
  id
  lastConnection
  lastName
  phoneNumbers
  role
  typesenseApiKey
  userId
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  avatarUrl: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  fullName: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastConnection: DateTimeWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  phoneNumbers: StringNullableListFilter
  role: EnumRoleWithAggregatesFilter
  typesenseApiKey: StringNullableWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input UserUpdateInput {
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  fullName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastConnection: DateTimeFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  phoneNumbers: UserUpdatephoneNumbersInput
  role: EnumRoleFieldUpdateOperationsInput
  typesenseApiKey: NullableStringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  avatarUrl: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  fullName: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastConnection: DateTimeFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  phoneNumbers: UserUpdatephoneNumbersInput
  role: EnumRoleFieldUpdateOperationsInput
  typesenseApiKey: NullableStringFieldUpdateOperationsInput
  userId: StringFieldUpdateOperationsInput
}

input UserUpdatephoneNumbersInput {
  push: [String!]
  set: [String!]
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatarUrl: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringNullableFilter
  fullName: StringNullableFilter
  id: StringFilter
  lastConnection: DateTimeFilter
  lastName: StringNullableFilter
  phoneNumbers: StringNullableListFilter
  role: EnumRoleFilter
  typesenseApiKey: StringNullableFilter
  userId: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatarUrl: StringNullableFilter
  createdAt: DateTimeFilter
  email: String
  firstName: StringNullableFilter
  fullName: StringNullableFilter
  id: String
  lastConnection: DateTimeFilter
  lastName: StringNullableFilter
  phoneNumbers: StringNullableListFilter
  role: EnumRoleFilter
  typesenseApiKey: StringNullableFilter
  userId: String
}